<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Networked multi-player plugin."><meta name="keywords" content="rust, rustlang, rust-lang, networking"><title>jumpy::networking - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../jumpy/index.html"><div class="logo-container"><img src="https://avatars.githubusercontent.com/u/87333478?s=200&amp;v=4" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../jumpy/index.html"><div class="logo-container">
                    <img src="https://avatars.githubusercontent.com/u/87333478?s=200&amp;v=4" alt="logo"></div></a><h2 class="location"><a href="#">Module networking</a></h2><div class="sidebar-elems"><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../jumpy/index.html">
                        <img src="https://avatars.githubusercontent.com/u/87333478?s=200&amp;v=4" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">jumpy</a>::<wbr><a class="mod" href="#">networking</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/jumpy/networking.rs.html#1-53">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Networked multi-player plugin.</p>
<p>Jumpy uses a Peer-to-Peer, rollback networking model built on <a href="https://github.com/gschup/ggrs">GGRS</a> and the <a href="https://github.com/gschup/bevy_ggrs"><code>bevy_ggrs</code></a> plugin.</p>
<p>We use a centralized matchmaking server to connect peers to each-other and to forward the peers’
network traffic. All connections utilize UDP and the QUIC protocol.</p>
<p>Messages are serialized/deserialized to a binary representation using <a href="https://docs.rs/serde"><code>serde</code></a> and the <a href="https://docs.rs/postcard"><code>postcard</code></a>
crate.</p>
<p>The major facets of our networking are:</p>
<ul>
<li><a href="#matchmaking">Matchmaking</a>: How we connect clients to each-other and start an online match.</li>
<li><a href="#synchronization">Synchronization</a>: How we synchronize a network game between multiple players.</li>
</ul>
<p>You may also want to see:</p>
<ul>
<li><a href="#future-changes">Future Changes</a> for some thoughts on changes we
might make to the current design.</li>
<li><a href="#development--debugging">Development &amp; Debuggin</a> for tips on testing networking during
development.</li>
</ul>
<h3 id="matchmaking"><a href="#matchmaking">Matchmaking</a></h3>
<p>In order to establish the peer connections we use a matchmaking server implemented in the
<a href="https://fishfolk.github.io/jumpy/developers/rustdoc/jumpy_matchmaker/index.html"><code>jumpy_matchmaker</code></a> crate. This server binds one UDP port and listens for client connections.
Because QUIC supports mutliplexing connections, we are able to handle any number of clients on a
single UDP port.</p>
<p>All client traffic is proxied to other peers through the matchmaking server. In this way it is not
true peer-to-peer networking, but logically, once the match starts, clients are sending messages to
each-other, and the server doesn’t take part in the match protocol.</p>
<p>Having the matchmaker proxy client messages has the following pros and cons:</p>
<p><strong>Cons:</strong></p>
<ul>
<li>It uses up more of the matchmaking server’s bandwidth</li>
<li>It adds an extra network hop between peers, increasing latency.</li>
</ul>
<p><strong>Pros:</strong></p>
<ul>
<li>It reduces the number of connections each peer needs to make. Each peer only holds one
connection to the matchmaking server and nothing else.</li>
<li>It hides the IP addresses of clients from each-other. This is an important privacy feature.</li>
<li>It avoids a number of difficulties that you may run into while trying to establish true
peer-to-peer connections, and makes it much easier to bypass firewalls, NATs, etc.</li>
</ul>
<p>This doesn’t prevent us from supporting true peer-to-peer connections in the future, though.
Similarly, another scenario we will support in the future is LAN games that you can join without
needing a matchmaking server.</p>
<h4 id="matchmaking-protocol"><a href="#matchmaking-protocol">Matchmaking Protocol</a></h4>
<blockquote>
<p><strong>ℹ️ Note:</strong> This is meant as an overview and is not an exact specification of the matchmaking
protocol.</p>
</blockquote>
<h5 id="initial-connection"><a href="#initial-connection">Initial Connection</a></h5>
<p>When a client connects to the matchmaking server, the very first thing it will do is send a
<a href="../../jumpy_matchmaker_proto/enum.MatchmakerRequest.html#variant.RequestMatch" title="jumpy_matchmaker_proto::MatchmakerRequest::RequestMatch"><code>RequestMatch</code></a> message to the server over
a reliable channel.</p>
<p>This message contains the <a href="../../jumpy_matchmaker_proto/struct.MatchInfo.html" title="jumpy_matchmaker_proto::MatchInfo"><code>MatchInfo</code></a> that tells the server
how many players the client wants to connect to for the match, along with an arbitrary byte sequence
for the <code>match_data</code>.</p>
<p>In order for players to end up in the same match as each-other, they must specify the <em>exact</em> same
<code>MatchInfo</code>, including the <code>match_data</code>. We use the <code>match_data</code> as a way to specify which game mode
and parameters, etc. that the player wants to connect to, so that all the players that are connected
to each-other are playing the same mode.</p>
<p>The <code>match_data</code> also contains the game name and version. Because the matchmaker does not take part
in the match protocol itself, just the matchmaking protocol, <strong>this makes the matchmaking server
game agnostic</strong>. Different games can connect to the same matchmaking server, and they can make sure
they are only connected to players playing the same game, by specifying a unique <code>match_data</code>.</p>
<blockquote>
<p><strong>Note:</strong> To be clear, the game implementation sets the <code>match_data</code> for players. Players are
never exposed directly to the concept of the <code>match_data</code>.</p>
</blockquote>
<h5 id="waiting-for-players"><a href="#waiting-for-players">Waiting For Players</a></h5>
<p>After the initial connection and match request, the server will send the client an
<a href="../../jumpy_matchmaker_proto/enum.MatchmakerResponse.html#variant.Accepted" title="jumpy_matchmaker_proto::MatchmakerResponse::Accepted"><code>Accepted</code></a> message.</p>
<p>If the waiting room for that match already has the desired number of players in it, the server will
then respond immediately with a <a href="../../jumpy_matchmaker_proto/enum.MatchmakerResponse.html#variant.Success" title="jumpy_matchmaker_proto::MatchmakerResponse::Success"><code>Success</code></a>
message. This message comes with:</p>
<ul>
<li>a <code>random_seed</code> that can be used by all clients to generate deterministic random numbers, and</li>
<li>a <code>player_idx</code> that tells the client <em>which</em> player in the match it is. This is used throughout
the game to keep track of the players, and is between <code>0</code> and <code>player_count - 1</code>.</li>
</ul>
<h5 id="in-the-match"><a href="#in-the-match">In the Match</a></h5>
<p>Immediately after the desired number of clients have joined and the <code>Success</code> message has been sent
to all players, the matchmaker goes into proxy mode for all clients in the match.</p>
<p>Once in proxy mode, the server listens for
<a href="../../jumpy_matchmaker_proto/struct.SendProxyMessage.html" title="jumpy_matchmaker_proto::SendProxyMessage"><code>SendProxyMessage</code></a>s from clients. Each message simply
specifies a <a href="../../jumpy_matchmaker_proto/enum.TargetClient.html" title="jumpy_matchmaker_proto::TargetClient"><code>TargetClient</code></a> ( either a specific client or all
of them ), and a binary message data.</p>
<p>Once it a <code>SendProxyMessage</code> it will send it to the target client, which will receive it in the form
of a <a href="../../jumpy_matchmaker_proto/struct.RecvProxyMessage.html" title="jumpy_matchmaker_proto::RecvProxyMessage"><code>RecvProxyMessage</code></a>, containing the message data,
and the index of the client that sent the message.</p>
<p>The matchmaking server supports forwarding both reliable and unreliable message in this way,
allowing the game to chose any kind of protocol it sees fit to synchronize the match data.</p>
<h3 id="synchronization"><a href="#synchronization">Synchronization</a></h3>
<p>Match synchronization, as mentioned above, is accomplished with <a href="https://github.com/gschup/ggrs">GGRS</a>, wich is a re-imagining of
the <a href="https://www.ggpo.net/">GGPO</a> network SDK.</p>
<p>We implement GGRS’s <a href="https://docs.rs/ggrs/0.9.2/ggrs/trait.NonBlockingSocket.html"><code>NonBlockingSocket</code></a> trait on top of our QUIC <code>Connection</code>, using QUIC’s raw
datagram feature to send messages unreliably. This way we can proxy all of the GGRS traffic through
the matchmaking server, while still allowing it to use it’s own reliability protocol.</p>
<p>All of the Bevy systems that need to be synchronized during a match are added to their own Bevy
<a href="../prelude/struct.Schedule.html" title="bevy::ecs::schedule::Schedule">Schedule</a>. We use an <a href="../schedule/trait.RollbackScheduleAppExt.html" title="crate::schedule::RollbackScheduleAppExt">extension
trait</a> on the Bevy <a href="../prelude/struct.App.html" title="bevy::app::App"><code>App</code></a> to make it
easier to add systems to the rollback schedule in our plugins throughout Jumpy.</p>
<p>The key requirement for rollback networking is:</p>
<ul>
<li>The synchronized game loop must be <strong>deterministic</strong>.</li>
<li>We must have the ability to <strong>snapshot</strong> and <strong>restore</strong> the game state.</li>
<li>We must be able to run up to 8 game simulation frames in 16ms ( to achieve a 60 FPS frame rate ).</li>
</ul>
<h4 id="determinism"><a href="#determinism">Determinism</a></h4>
<p>Luckily, Jumpy’s physics and game logic is simple and we don’t face any major non-determinism
issues. The primary source of potential non-determinism is Bevy’s query iteration order and entity
allocation.</p>
<h5 id="sorting-queries"><a href="#sorting-queries">Sorting Queries</a></h5>
<p>Because Bevy doesn’t guarantee any specific order for entity iteration, we have to manually collect
and sort queries when a different order could produce a different in-game result.</p>
<p>For all rollback entities, we can simply collect the query results into a <a href="https://doc.rust-lang.org/1.65.0/alloc/vec/struct.Vec.html" title="Vec"><code>Vec</code></a> and sort by the
<a href="../prelude/struct.Rollback.html" title="Rollback"><code>Rollback</code></a> component’s id, but sometimes we have non-rollback entities such as the map element
spawners that we also need to iterate over. For those we have a simple <a href="../utils/struct.Sort.html" title="crate::utils::Sort"><code>Sort</code></a>
component that just stores an index. We get that index from something deterministic, such as the
order that the map elements appear in the map YAML file.</p>
<p>It’s easy to accidentally forget to sort entities when querying, and you may not notice issues until
you try to run a network game, and the clients end up playing a “different version” of the same
game. We hope we can improve this: see <a href="#future-changes">Future Changes</a>.</p>
<h5 id="spawning-entities"><a href="#spawning-entities">Spawning Entities</a></h5>
<p>When spawning entities, we need to attach <a href="../prelude/struct.Rollback.html" title="bevy_ggrs::Rollback"><code>Rollback</code></a> components to them, that
contain a unique index identifying the entity across rollbacks and restores, which may modify the
Entity’s entity ID.</p>
<p>We must be careful every time we spawn an item, that we deterministically assign the same <code>Rid</code> to
the entity on all clients. This mostly boils down to making sure we spawn them in the same order.</p>
<h4 id="snapshot--restore"><a href="#snapshot--restore">Snapshot &amp; Restore</a></h4>
<p>All of the components that need to be synchronized during rollback must be registered with the
<a href="https://github.com/gschup/bevy_ggrs"><code>bevy_ggrs</code></a> plugin. This is usually done in the Bevy plugin that adds the component, by calling
<a href="../schedule/trait.RollbackScheduleAppExt.html#tymethod.extend_rollback_plugin" title="crate::schedule::RollbackScheduleAppExt::extend_rollback_plugin"><code>extend_rollback_plugin()</code></a> using
the extension trait on the Bevy <code>App</code> type.</p>
<p>The <a href="https://github.com/gschup/bevy_ggrs"><code>bevy_ggrs</code></a> plugin will then make sure that that component is snapshot and restored during
rollback and restore.</p>
<p>Currently <a href="https://github.com/gschup/bevy_ggrs"><code>bevy_ggrs</code></a> requires a <a href="../prelude/trait.Reflect.html" title="bevy::reflect::Reflect"><code>Reflect</code></a> implementation on components
that will be synchronized, and it uses the <code>Reflect</code> implementation to clone the objects. We have
noticed that snapshot and restore using this technique can take up to 1ms. There are already plans,
once Bevy lands it’s “Stageless” implementation, to re-implement <a href="https://github.com/gschup/bevy_ggrs"><code>bevy_ggrs</code></a> and remove the
<code>Reflect</code> requirement, which should improve snapshot performance.</p>
<p>This is important because it is hard to fit 8 frames into a 16ms time period, and taking a whole 1ms
to snapshot cuts down on how many frames we can run in that period of time.</p>
<h3 id="future-changes"><a href="#future-changes">Future Changes</a></h3>
<p>These are some ideas for future changes to the networking strategy.</p>
<h4 id="encapsulate-core-match-logic-in-an-isolated-micro-ecs"><a href="#encapsulate-core-match-logic-in-an-isolated-micro-ecs">Encapsulate Core Match Logic in an Isolated Micro ECS</a></h4>
<p>In order to improve our determinism and snapshot/restore story, we are
discussing ( see <a href="https://github.com/fishfolk/jumpy/discussions/489">#489</a> and <a href="https://github.com/fishfolk/jumpy/discussions/510">#510</a> ) an alternative architecture for handling the synchronization of
the match state.</p>
<p>The idea is to move the core match game loop into it’s own, tiny ECS that doesn’t have the
non-deterministic iteration order problem, and that can also be snapshot and restored simply by
copying the entire ECS world.</p>
<p>This creates a healthy isolation between Bevy and it’s various resources and entities, and our core
game loop. Additionally, we may put this isolated ECS in a WASM module to allow for hot reloading
core game logic, and enabling mods in the future.</p>
<h3 id="development--debugging"><a href="#development--debugging">Development &amp; Debugging</a></h3>
<p>Here are some tips for debugging networking features while developing.</p>
<h4 id="local-sync-test"><a href="#local-sync-test">Local Sync Test</a></h4>
<p>It can be cumbersome to start a new networked match every time you need to troubleshoot some part of
the game that may not be rolling back or restoring properly. To help with this, you can run the game
with the <code>--sync-test-check-distance 7</code> to make the game test rolling back and forward 8 times every
frame as a test when starting a local game.</p>
<p>This allows you to test the rollback without having to connect to a server. If things start popping
around the map or having other weird behaviors that they don’t have without the sync-test mode, then
you know you have a rollback issue.</p>
<blockquote>
<p><strong>ℹ️ Note:</strong> Just because you <strong>don’t</strong> have an issue in sync test mode, doesn’t mean that there
is no determinism issues. You still have to test network games with multiple game instances. There
are some non-determinism issues that only exhibit themselves when restarting the game.</p>
</blockquote>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="client/index.html" title="jumpy::networking::client mod">client</a></div><div class="item-right docblock-short">The Bevy network client implementation.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="proto/index.html" title="jumpy::networking::proto mod">proto</a></div><div class="item-right docblock-short">Serializable data types for network messages used by the game.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.NetworkingPlugin.html" title="jumpy::networking::NetworkingPlugin struct">NetworkingPlugin</a></div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.listen_for_map_changes.html" title="jumpy::networking::listen_for_map_changes fn">listen_for_map_changes</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="item-right docblock-short">TODO: Map changes aren’t working on network games for now, so this isn’t properly used/working.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="jumpy" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>